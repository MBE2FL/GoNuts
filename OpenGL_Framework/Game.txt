#include "Game.h"

#include <string>

int GetShaderUniformLocation(std::string name)
{
	return 0;
}

const float mesh[] = {
	// Vertices start here:
	-1.0f, 	-1.0f, 	-1.0f, 	 // triangle 1, Vertex 1
	-1.0f, 	-1.0f, 	 1.0f, 	 // triangle 1, Vertex 2
	-1.0f, 	 1.0f, 	 1.0f, 	 // triangle 1, Vertex 3
	1.0f, 	 1.0f, 	-1.0f, 	 // triangle 2, Vertex 1
	-1.0f, 	-1.0f, 	-1.0f, 	 // triangle 2, Vertex 2
	-1.0f, 	 1.0f, 	-1.0f, 	 // triangle 2, Vertex 3
	1.0f, 	-1.0f, 	 1.0f,
	-1.0f, 	-1.0f, 	-1.0f,
	1.0f, 	-1.0f, 	-1.0f,
	1.0f, 	 1.0f, 	-1.0f,
	1.0f, 	-1.0f, 	-1.0f,
	-1.0f, 	-1.0f, 	-1.0f,
	-1.0f, 	-1.0f, 	-1.0f,
	-1.0f, 	 1.0f, 	 1.0f,
	-1.0f, 	 1.0f, 	-1.0f,
	1.0f, 	-1.0f, 	 1.0f,
	-1.0f, 	-1.0f, 	 1.0f,
	-1.0f, 	-1.0f, 	-1.0f,
	-1.0f, 	 1.0f, 	 1.0f,
	-1.0f, 	-1.0f, 	 1.0f,
	1.0f, 	-1.0f, 	 1.0f,
	1.0f, 	 1.0f, 	 1.0f,
	1.0f, 	-1.0f, 	-1.0f,
	1.0f, 	 1.0f, 	-1.0f,
	1.0f, 	-1.0f, 	-1.0f,
	1.0f, 	 1.0f, 	 1.0f,
	1.0f, 	-1.0f, 	 1.0f,
	1.0f, 	 1.0f, 	 1.0f,
	1.0f, 	 1.0f, 	-1.0f,
	-1.0f, 	 1.0f, 	-1.0f,
	1.0f, 	 1.0f, 	 1.0f,
	-1.0f, 	 1.0f, 	-1.0f,
	-1.0f, 	 1.0f, 	 1.0f,
	1.0f, 	 1.0f, 	 1.0f,
	-1.0f, 	 1.0f, 	 1.0f,
	1.0f, 	-1.0f, 	 1.0f,
	// Colors start here:
	0.583f,  0.771f,  0.014f,
	0.609f,  0.115f,  0.436f,
	0.327f,  0.483f,  0.844f,
	0.822f,  0.569f,  0.201f,
	0.435f,  0.602f,  0.223f,
	0.310f,  0.747f,  0.185f,
	0.597f,  0.770f,  0.761f,
	0.559f,  0.436f,  0.730f,
	0.359f,  0.583f,  0.152f,
	0.483f,  0.596f,  0.789f,
	0.559f,  0.861f,  0.639f,
	0.195f,  0.548f,  0.859f,
	0.014f,  0.184f,  0.576f,
	0.771f,  0.328f,  0.970f,
	0.406f,  0.615f,  0.116f,
	0.676f,  0.977f,  0.133f,
	0.971f,  0.572f,  0.833f,
	0.140f,  0.616f,  0.489f,
	0.997f,  0.513f,  0.064f,
	0.945f,  0.719f,  0.592f,
	0.543f,  0.021f,  0.978f,
	0.279f,  0.317f,  0.505f,
	0.167f,  0.620f,  0.077f,
	0.347f,  0.857f,  0.137f,
	0.055f,  0.953f,  0.042f,
	0.714f,  0.505f,  0.345f,
	0.783f,  0.290f,  0.734f,
	0.722f,  0.645f,  0.174f,
	0.302f,  0.455f,  0.848f,
	0.225f,  0.587f,  0.040f,
	0.517f,  0.713f,  0.338f,
	0.053f,  0.959f,  0.120f,
	0.393f,  0.621f,  0.362f,
	0.673f,  0.211f,  0.457f,
	0.820f,  0.883f,  0.371f,
	0.982f,  0.099f,  0.879f
};

const char* vertexShaderSource = 
	"#version 330\n"
	"layout(location = 0) in vec3 mesh_position;\n"
	"layout(location = 1) in vec3 mesh_color;\n"
	"uniform mat4 u_model;\n"
	"uniform mat4 u_view;\n"
	"uniform mat4 u_projection;\n"
	"out vec3 color;\n"
	"void main()\n"
	"{\n"
	"	gl_Position = u_projection * u_view * u_model * vec4(mesh_position, 1.0);\n"
	"	color = mesh_color;\n"
	"}\n";

const char* fragmentShaderSource = 
	"#version 330\n"
	"in vec3 color;\n"
	"out vec4 pixelColor;\n"
	"void main() { pixelColor = vec4(color, 1.0f); }\n";

Game::Game()
{
}

Game::~Game()
{
	delete updateTimer;

	//...
}

void Game::initializeGame()
{
	// Create Vertex Array Object (VAO).
	glGenVertexArrays(1, &VAO);
	glBindVertexArray(VAO);

	// Create Vertex Buffer Object (VBO) and send mesh to VRAM.
	glGenBuffers(1, &VBO);
	glBindBuffer(GL_ARRAY_BUFFER, VBO);
	glBufferData(GL_ARRAY_BUFFER, sizeof(mesh), mesh, GL_STATIC_DRAW); // Data sent here.

	glEnableVertexAttribArray(0);
	glEnableVertexAttribArray(1);

	glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, 0);
	glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 0, reinterpret_cast<void*>(3 * 3 * 12 * sizeof(float)));

	int success = GL_FALSE;
	// Load shaders
	shaderProgram = glCreateProgram();

	// Create Vertex Shader //
	vertShader = glCreateShader(GL_VERTEX_SHADER);
	glShaderSource(vertShader, 1, &vertexShaderSource, nullptr);
	glCompileShader(vertShader);
	
	glGetShaderiv(vertShader, GL_COMPILE_STATUS, &success);
	if (success == GL_FALSE) { exit(EXIT_FAILURE); };

	// Create Fragment Shader //
	fragShader = glCreateShader(GL_FRAGMENT_SHADER);
	glShaderSource(fragShader, 1, &fragmentShaderSource, nullptr);
	glCompileShader(fragShader);

	glGetShaderiv(fragShader, GL_COMPILE_STATUS, &success);
	if (success == GL_FALSE) { exit(EXIT_FAILURE); };

	// Finish linking the program object
	glAttachShader(shaderProgram, vertShader);
	glAttachShader(shaderProgram, fragShader);
	glLinkProgram(shaderProgram);
	
	glGetProgramiv(shaderProgram, GL_LINK_STATUS, &success);
	if (success == GL_FALSE) { exit(EXIT_FAILURE); };

	// Scene Setup.
	float aspect = static_cast<float>(WINDOW_WIDTH) / static_cast<float>(WINDOW_HEIGHT);
	camera.perspective(60.0f, aspect, 1, 1000.0f);
	camera.m_pLocalPosition = vec3(0.0f, 4.0f, 4.0f);
	camera.setRotationAngleX(-45.0f);

	updateTimer = new Timer();
}

void Game::update()
{
	// update our clock so we have the delta time since the last update
	updateTimer->tick();

	float deltaTime = updateTimer->getElapsedTimeSeconds();
	TotalGameTime += deltaTime;

	cube.setRotationAngleY(TotalGameTime * 15.0f);

	camera.update(deltaTime);
	cube.update(deltaTime);
}

void Game::draw()
{
	glEnable(GL_DEPTH_TEST);
	glClearColor(0, 0, 0, 0);
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

	// Bind shader.
	glUseProgram(shaderProgram);

	// Send data to shader.
	int modelLoc      = glGetUniformLocation(shaderProgram, "u_model");
	int viewLoc	      = glGetUniformLocation(shaderProgram, "u_view");
	int projectionLoc = glGetUniformLocation(shaderProgram, "u_projection");

	glUniformMatrix4fv(modelLoc,      1, false, cube.getLocalToWorldMatrix().data);
	glUniformMatrix4fv(viewLoc,		  1, false, camera.getLocalToWorldMatrix().GetInverse().data);
	glUniformMatrix4fv(projectionLoc, 1, false, camera.getProjection().data);

	// Bind Mesh.
	glBindVertexArray(VAO); // The VAO remembers all of the streams and buffers needed for the mesh.
	glDrawArrays(GL_TRIANGLES, 0, 12 * 3); // Number of vertices = 12 triangles * 3 vertices per triangle.

	// Cleanup.
	glBindVertexArray(GL_NONE);
	glUseProgram(GL_NONE);

	glutSwapBuffers();
}

void Game::keyboardDown(unsigned char key, int mouseX, int mouseY)
{
	switch(key)
	{
	case 27: // the escape key
	case 'q': // the 'q' key
		exit(1);
		break;
	}
}

void Game::keyboardUp(unsigned char key, int mouseX, int mouseY)
{
	switch(key)
	{
	case 32: // the space bar
		break;
	case 27: // the escape key
	case 'q': // the 'q' key
		exit(1);
		break;
	}
}

void Game::mouseClicked(int button, int state, int x, int y)
{
	if(state == GLUT_DOWN) 
	{
		switch(button)
		{
		case GLUT_LEFT_BUTTON:

			break;
		case GLUT_RIGHT_BUTTON:
		
			break;
		case GLUT_MIDDLE_BUTTON:

			break;
		}
	}
	else
	{

	}
}

/*
 * mouseMoved(x,y)
 * - this occurs only when the mouse is pressed down
 *   and the mouse has moved.  you are given the x,y locations
 *   in window coordinates (from the top left corner) and thus 
 *   must be converted to screen coordinates using the screen to window pixels ratio
 *   and the y must be flipped to make the bottom left corner the origin.
 */
void Game::mouseMoved(int x, int y)
{
}
